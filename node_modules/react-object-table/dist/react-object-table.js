(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"), require("react-dom"), require("jquery"));
	else if(typeof define === 'function' && define.amd)
		define(["react", "react-dom", "jquery"], factory);
	else if(typeof exports === 'object')
		exports["react-object-table"] = factory(require("react"), require("react-dom"), require("jquery"));
	else
		root["react-object-table"] = factory(root["react"], root["react-dom"], root["jquery"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_11__, __WEBPACK_EXTERNAL_MODULE_12__, __WEBPACK_EXTERNAL_MODULE_13__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.TextDrawer = exports.TextEditor = exports.BaseEditor = exports.ObjectRow = exports.ObjectCell = undefined;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _propTypes = __webpack_require__(1);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _react = __webpack_require__(11);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(12);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _jquery = __webpack_require__(13);

	var _jquery2 = _interopRequireDefault(_jquery);

	var _classnames = __webpack_require__(14);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _clone = __webpack_require__(15);

	var _clone2 = _interopRequireDefault(_clone);

	var _utilities = __webpack_require__(20);

	var _clipboard = __webpack_require__(21);

	var _text = __webpack_require__(22);

	var _text2 = _interopRequireDefault(_text);

	var _text3 = __webpack_require__(24);

	var _text4 = _interopRequireDefault(_text3);

	var _baseEditor = __webpack_require__(23);

	var _baseEditor2 = _interopRequireDefault(_baseEditor);

	var _objectCell = __webpack_require__(25);

	var _objectCell2 = _interopRequireDefault(_objectCell);

	var _objectRow = __webpack_require__(26);

	var _objectRow2 = _interopRequireDefault(_objectRow);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _iOSDevice = false;
	if (typeof navigator !== 'undefined') {
	  _iOSDevice = !!navigator.platform.match(/iPhone|iPod|iPad/);
	}

	var ObjectTable = function (_React$PureComponent) {
	  _inherits(ObjectTable, _React$PureComponent);

	  function ObjectTable() {
	    var _ref;

	    var _temp, _this, _ret;

	    _classCallCheck(this, ObjectTable);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ObjectTable.__proto__ || Object.getPrototypeOf(ObjectTable)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
	      editing: null,
	      editReplace: null,

	      selectionDragStart: null,

	      selectedRows: {},
	      selectedColumns: {},
	      selectedRowsDown: true,
	      selectedColumnsRight: true,

	      copyingRows: {},
	      copyingColumns: {},

	      openActions: null
	    }, _this.handleKeyPress = function (event) {
	      if (_this.state.editing === null) {
	        var editRow = _this.getSelectedFirstVisibleRow();
	        var editColumn = _this.getSelectedFirstVisibleColumn();
	        if (editRow !== null && editColumn !== null) {
	          var editObject = void 0;
	          for (var objectIndex = 0; objectIndex < _this.props.objects.length; objectIndex++) {
	            var object = _this.props.objects[objectIndex];
	            if (object.id === editRow) editObject = object;
	          }
	          switch (event.which) {
	            // case 'enter':
	            case 13:
	              if ((0, _utilities.cellIsEditable)(editRow, _this.getColumnFromKey(editColumn)) && editObject && !editObject.disabled) {
	                _this.setState({
	                  editing: {
	                    columnKey: editColumn,
	                    objectId: editRow
	                  },
	                  editReplace: null
	                });
	              }
	              event.preventDefault();
	              break;

	            default:
	              if ((0, _utilities.cellIsEditable)(editRow, _this.getColumnFromKey(editColumn)) && editObject && !editObject.disabled) {
	                _this.setState({
	                  editing: {
	                    columnKey: editColumn,
	                    objectId: editRow
	                  },
	                  editReplace: String.fromCharCode(event.which) // keyPressed
	                });
	              }
	              event.preventDefault();
	              break;
	          }
	        }
	      }
	    }, _this.handleKeyDown = function (event) {
	      var directionKeys = {
	        38: 'arrow_up',
	        40: 'arrow_down',
	        37: 'arrow_left',
	        39: 'arrow_right'
	      };
	      var actionKeys = {
	        27: 'escape',
	        9: 'tab',
	        8: 'backspace'
	      };
	      if (_this.state.editing === null) {
	        var selectedCells = Object.keys(_this.state.selectedRows).length;
	        selectedCells *= Object.keys(_this.state.selectedColumns).length;
	        if (selectedCells > 0) {
	          switch (directionKeys[event.which]) {
	            case 'arrow_up':
	              if (event.shiftKey) {
	                var newRows = (0, _clone2.default)(_this.state.selectedRows);
	                if (Object.keys(_this.state.selectedRows).length > 1 && _this.state.selectedRowsDown) {
	                  delete newRows[_this.getSelectedFirstVisibleRow(true)];
	                } else {
	                  newRows[_this.getSelectedNextVisibleRow(true)] = true;
	                }
	                _this.changeSelectionTo(newRows, _this.state.selectedColumns);
	              } else {
	                _this.moveSelectionTo(_this.getSelectedNextVisibleRow(true), _this.getSelectedFirstVisibleColumn());
	              }
	              break;

	            case 'arrow_down':
	              if (event.shiftKey) {
	                var _newRows = (0, _clone2.default)(_this.state.selectedRows);
	                if (Object.keys(_this.state.selectedRows).length > 1 && !_this.state.selectedRowsDown) {
	                  delete _newRows[_this.getSelectedFirstVisibleRow()];
	                } else {
	                  _newRows[_this.getSelectedNextVisibleRow()] = true;
	                }
	                _this.changeSelectionTo(_newRows, _this.state.selectedColumns);
	              } else {
	                _this.moveSelectionTo(_this.getSelectedNextVisibleRow(), _this.getSelectedFirstVisibleColumn());
	              }
	              break;

	            case 'arrow_left':
	              if (event.shiftKey) {
	                var newColumns = (0, _clone2.default)(_this.state.selectedColumns);
	                if (Object.keys(_this.state.selectedColumns).length > 1 && _this.state.selectedColumnsRight) {
	                  delete newColumns[_this.getSelectedFirstVisibleColumn(true)];
	                } else {
	                  newColumns[_this.getSelectedNextVisibleColumn(true)] = true;
	                }
	                _this.changeSelectionTo(_this.state.selectedRows, newColumns);
	              } else {
	                _this.moveSelectionTo(_this.getSelectedFirstVisibleRow(), _this.getSelectedNextVisibleColumn(true));
	              }
	              break;

	            case 'arrow_right':
	              if (event.shiftKey) {
	                var _newColumns = (0, _clone2.default)(_this.state.selectedColumns);
	                if (Object.keys(_this.state.selectedColumns).length > 1 && !_this.state.selectedColumnsRight) {
	                  delete _newColumns[_this.getSelectedFirstVisibleColumn()];
	                } else {
	                  _newColumns[_this.getSelectedNextVisibleColumn()] = true;
	                }
	                _this.changeSelectionTo(_this.state.selectedRows, _newColumns);
	              } else {
	                _this.moveSelectionTo(_this.getSelectedFirstVisibleRow(), _this.getSelectedNextVisibleColumn());
	              }
	              break;
	          }
	          switch (actionKeys[event.which]) {
	            case 'escape':
	              if (Object.keys(_this.state.copyingColumns).length > 0 || Object.keys(_this.state.copyingRows).length > 0) {
	                _this.setState({
	                  copyingColumns: {},
	                  copyingRows: {}
	                });
	              }
	              break;

	            case 'backspace':
	              var editColumn = _this.getSelectedFirstVisibleColumn();
	              var editRow = _this.getSelectedFirstVisibleRow();
	              if (selectedCells > 0 && (0, _utilities.cellIsEditable)(editRow, _this.getColumnFromKey(editColumn))) {
	                _this.setState({
	                  editing: {
	                    columnKey: editColumn,
	                    objectId: editRow
	                  },
	                  editReplace: ''
	                });
	              }
	              break;

	            case 'tab':
	              if (typeof _this.state.selectedColumns[_this.getSelectedNextVisibleColumn()] === 'undefined') {
	                _this.moveSelectionTo(_this.getSelectedFirstVisibleRow(), _this.getSelectedNextVisibleColumn());
	              } else {
	                _this.moveSelectionTo(_this.getSelectedNextVisibleRow(), _this.props.columns[0].key);
	              }
	              break;
	          }
	          if (typeof directionKeys[event.which] !== 'undefined' || typeof actionKeys[event.which] !== 'undefined') {
	            event.preventDefault();
	          }
	        }
	      }
	    }, _this.beginEdit = function (ref, editReplaceOverride) {
	      var editReplace = null;
	      if (typeof editReplaceOverride !== 'undefined') {
	        editReplace = editReplaceOverride;
	      }
	      _this.setState({ editing: ref, editReplace: editReplace });
	    }, _this.handleMouseDownCell = function (ref, clientX, clientY, shift) {
	      if (_iOSDevice) {
	        _this.beginEdit(ref);
	        return;
	      }

	      if (_this.state.editing !== null) {
	        _this.handleClickOutside({});
	        return;
	      }

	      var mouseX = clientX;
	      var mouseY = clientY;
	      var clickRef = ref;
	      if (_this.state.selectionDragStart === null) {
	        if (shift) {
	          var currentColumn = _this.getSelectedFirstVisibleColumn(!_this.state.selectedColumnsRight);
	          var currentRow = _this.getSelectedFirstVisibleRow(!_this.state.selectedRowsDown);

	          var selectingDown = void 0;
	          var selectingRight = void 0;
	          for (var rowIndex = 0; rowIndex < _this.props.objects.length; rowIndex++) {
	            var row = _this.props.objects[rowIndex];
	            if (row.id === currentRow) {
	              selectingDown = true;
	              break;
	            }
	            if (row.id === ref.objectId) {
	              selectingDown = false;
	              break;
	            }
	          }
	          for (var columnIndex = 0; columnIndex < _this.props.columns.length; columnIndex++) {
	            var column = _this.props.columns[columnIndex];
	            if (column.key === currentColumn) {
	              selectingRight = true;
	              break;
	            }
	            if (column.key === ref.columnKey) {
	              selectingRight = false;
	              break;
	            }
	          }

	          var newSelectionRows = {};
	          var selecting = false;
	          for (var _rowIndex = 0; _rowIndex < _this.props.objects.length; _rowIndex++) {
	            var _row = _this.props.objects[_rowIndex];
	            if (selectingDown && _row.id === currentRow || !selectingDown && _row.id === ref.objectId) {
	              selecting = true;
	            }
	            if (selecting) newSelectionRows[_row.id] = true;
	            if (selectingDown && _row.id === ref.objectId || !selectingDown && _row.id === currentRow) {
	              break;
	            }
	          }
	          var newSelectionColumns = {};
	          selecting = false;
	          for (var _columnIndex = 0; _columnIndex < _this.props.columns.length; _columnIndex++) {
	            var _column = _this.props.columns[_columnIndex];
	            if (selectingRight && _column.key === currentColumn || !selectingRight && _column.key === ref.columnKey) {
	              selecting = true;
	            }
	            if (selecting) newSelectionColumns[_column.key] = true;
	            if (selectingRight && _column.key === ref.columnKey || !selectingRight && _column.key === currentColumn) {
	              break;
	            }
	          }

	          _this.setState({
	            selectedColumns: newSelectionColumns,
	            selectedRows: newSelectionRows,
	            selectedRowsDown: selectingDown,
	            selectedColumnsRight: selectingRight
	          });
	        } else {
	          _this.setState(function (prevState) {
	            var stateChanges = {
	              selectionDragStart: {
	                x: mouseX + document.body.scrollLeft,
	                y: mouseY + document.body.scrollTop
	              },
	              selectedRows: prevState.selectedRows,
	              selectedColumns: prevState.selectedColumns
	            };
	            stateChanges.selectedRows[clickRef.objectId] = true;
	            stateChanges.selectedColumns[clickRef.columnKey] = true;
	            return stateChanges;
	          });
	        }
	      }

	      _this.closeActions();
	    }, _this.handleMouseMove = function (event) {
	      if (_this.state.selectionDragStart !== null) {
	        var mouseX = event.clientX + document.body.scrollLeft;
	        var mouseY = event.clientY + document.body.scrollTop;
	        _this.setState(function (prevState) {
	          var tableBounds = _this.table.getBoundingClientRect();
	          return {
	            selectedColumns: _this.getDraggedColumns(prevState.selectionDragStart.x, mouseX, tableBounds),
	            selectedRows: _this.getDraggedRows(prevState.selectionDragStart.y, mouseY, tableBounds),
	            selectedColumnsRight: true,
	            selectedRowsDown: true
	          };
	        });
	      }
	    }, _this.handleMouseUp = function (event) {
	      if (_this.state.selectionDragStart !== null) {
	        var mouseX = event.clientX + document.body.scrollLeft;
	        var mouseY = event.clientY + document.body.scrollTop;
	        _this.setState(function (prevState) {
	          var tableBounds = _this.table.getBoundingClientRect();
	          return {
	            selectedColumnsRight: prevState.selectionDragStart.x < mouseX,
	            selectedRowsDown: prevState.selectionDragStart.y < mouseY,
	            selectedColumns: _this.getDraggedColumns(prevState.selectionDragStart.x, mouseX, tableBounds),
	            selectedRows: _this.getDraggedRows(prevState.selectionDragStart.y, mouseY, tableBounds),
	            selectionDragStart: null
	          };
	        });
	      }
	    }, _this.abortField = function (action) {
	      _this.setState({ editing: null });
	    }, _this.updateField = function (objectId, columnKey, newValue, action) {
	      var updates = {};
	      updates[columnKey] = newValue;
	      _this.updateObject(objectId, updates);

	      var updateAction = action;
	      _this.setState(function (prevState) {
	        var stateChanges = { editing: null };
	        if ((0, _utilities.dictCount)(prevState.selectedRows) === 1 && (0, _utilities.dictCount)(prevState.selectedColumns) === 1) {
	          switch (updateAction) {
	            case 'nextRow':
	              stateChanges.selectedRows = {};
	              stateChanges.selectedRows[_this.getSelectedNextVisibleRow()] = true;
	              break;

	            case 'nextColumn':
	              stateChanges.selectedColumns = {};
	              stateChanges.selectedColumns[_this.getSelectedNextVisibleColumn()] = true;
	              break;
	          }
	        }
	        return stateChanges;
	      });
	    }, _this.openActions = function (id) {
	      _this.setState({ openActions: id });
	    }, _this.closeActions = function () {
	      if (_this.state.openActions === null) {
	        return;
	      }
	      _this.setState({ openActions: null });
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  _createClass(ObjectTable, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      var _this2 = this;

	      (0, _jquery2.default)(document).on('mousemove', this.handleMouseMove);
	      (0, _jquery2.default)(document).on('keypress', this.handleKeyPress);
	      (0, _jquery2.default)(document).on('keydown', this.handleKeyDown);
	      (0, _jquery2.default)(document).on('mouseup', function (event) {
	        var parentContainer = (0, _jquery2.default)(event.target).closest('.object-table-container');
	        if (parentContainer.length === 1) {
	          try {
	            if (parentContainer[0] === _reactDom2.default.findDOMNode(_this2)) return;
	          } catch (error) {}
	        }
	        if (_this2.state.selectionDragStart === null) {
	          _this2.handleClickOutside(event);
	        }
	      });
	      (0, _jquery2.default)(document).on('mouseup', this.handleMouseUp);
	      (0, _jquery2.default)(document).on('copy', function (event) {
	        var theEvent = event;
	        if (Object.keys(_this2.state.selectedColumns).length > 0 || Object.keys(_this2.state.selectedRows).length) {
	          _this2.handleCopy(theEvent);
	        }
	      });
	      (0, _jquery2.default)(document).on('paste', function (event) {
	        var theEvent = event;
	        var clipboardObjects = (0, _clipboard.deserializeCells)(theEvent.originalEvent.clipboardData);
	        if (clipboardObjects.length) {
	          _this2.handlePaste(clipboardObjects);
	        }
	      });
	    }
	  }, {
	    key: 'getEventCellRef',
	    value: function getEventCellRef(event) {
	      var cell = (0, _jquery2.default)(event.target);
	      if (!cell.is('td')) cell = cell.closest('td');
	      var objectId = cell.data('object-id');
	      var columnKey = cell.data('column-key');
	      return {
	        objectId: objectId,
	        columnKey: columnKey
	      };
	    }
	  }, {
	    key: 'getDraggedColumns',
	    value: function getDraggedColumns(startX, endX, tableBounds) {
	      var _this3 = this;

	      var cols = {};

	      var tableLeft = tableBounds.left + document.body.scrollLeft;

	      var lowestX = startX;
	      var highestX = endX;
	      if (lowestX > highestX) {
	        var tempX = lowestX;
	        lowestX = highestX;
	        highestX = tempX;
	      }
	      this.props.columns.map(function (column) {
	        var colElem = _this3.refs['header-' + column.key];
	        var colLeft = tableLeft + colElem.offsetLeft;
	        var colRight = colLeft + colElem.offsetWidth;

	        var inLeft = colRight >= lowestX && colLeft <= highestX;
	        var inRight = colLeft <= highestX && colRight >= lowestX;
	        if (inLeft || inRight) cols[column.key] = true;
	      });

	      return cols;
	    }
	  }, {
	    key: 'getDraggedRows',
	    value: function getDraggedRows(startY, endY, tableBounds) {
	      var rows = {};

	      var tableTop = tableBounds.top + document.body.scrollTop;

	      var lowestY = startY;
	      var highestY = endY;
	      if (lowestY > highestY) {
	        var tempY = lowestY;
	        lowestY = highestY;
	        highestY = tempY;
	      }
	      for (var rowIndex = 0; rowIndex < this.props.objects.length; rowIndex++) {
	        var object = this.props.objects[rowIndex];
	        var rowElem = _reactDom2.default.findDOMNode(this.getRowFromRefs(object.id));
	        if (!rowElem) {
	          continue;
	        }
	        var rowTop = tableTop + rowElem.offsetTop;
	        var rowBottom = rowTop + rowElem.offsetHeight;

	        var inTop = rowBottom >= lowestY && rowTop < highestY;
	        var inBottom = rowTop < highestY && rowBottom >= lowestY;
	        if (inTop || inBottom) rows[object.id] = true;
	      }

	      return rows;
	    }
	  }, {
	    key: 'getSelectedFirstVisibleRow',
	    value: function getSelectedFirstVisibleRow(reverse) {
	      var allRows = (0, _clone2.default)(this.props.objects || []);
	      if (reverse) allRows = allRows.reverse();

	      for (var rowIndex = 0; rowIndex < allRows.length; rowIndex++) {
	        var row = allRows[rowIndex];
	        if (typeof this.state.selectedRows[row.id] !== 'undefined') {
	          return row.id;
	        }
	      }
	      return null;
	    }
	  }, {
	    key: 'getSelectedFirstVisibleColumn',
	    value: function getSelectedFirstVisibleColumn(reverse) {
	      var allColumns = (0, _clone2.default)(this.props.columns);
	      if (reverse) allColumns = allColumns.reverse();

	      for (var columnIndex = 0; columnIndex < allColumns.length; columnIndex++) {
	        var column = allColumns[columnIndex];
	        if (typeof this.state.selectedColumns[column.key] !== 'undefined') {
	          return column.key;
	        }
	      }
	      return null;
	    }
	  }, {
	    key: 'getSelectedNextVisibleRow',
	    value: function getSelectedNextVisibleRow(reverse) {
	      var allRows = (0, _clone2.default)(this.props.objects || []);
	      if (reverse) allRows = allRows.reverse();

	      var couldBeNext = false;
	      var next = allRows.length ? allRows[0].id : null;

	      for (var rowIndex = 0; rowIndex < allRows.length; rowIndex++) {
	        var row = allRows[rowIndex];
	        if (couldBeNext) {
	          next = row.id;
	          couldBeNext = false;
	        }
	        if (typeof this.state.selectedRows[row.id] !== 'undefined') {
	          next = row.id;
	          couldBeNext = true;
	        }
	      }
	      return next;
	    }
	  }, {
	    key: 'getSelectedNextVisibleColumn',
	    value: function getSelectedNextVisibleColumn(reverse) {
	      var allColumns = (0, _clone2.default)(this.props.columns);
	      if (reverse) allColumns = allColumns.reverse();

	      var couldBeNext = false;
	      var next = allColumns.length ? allColumns[0].id : null;

	      for (var columnIndex = 0; columnIndex < allColumns.length; columnIndex++) {
	        var column = allColumns[columnIndex];
	        if (couldBeNext) {
	          next = column.key;
	          couldBeNext = false;
	        }
	        if (typeof this.state.selectedColumns[column.key] !== 'undefined') {
	          next = column.key;
	          couldBeNext = true;
	        }
	      }
	      return next;
	    }
	  }, {
	    key: 'getRowFromRefs',
	    value: function getRowFromRefs(rowId) {
	      // Dumb hack to clean up existing hack.
	      var row = this.refs['object-' + rowId];
	      // Unwrap
	      while (row.decoratedComponentInstance) {
	        row = row.decoratedComponentInstance;
	      }
	      return row;
	    }
	  }, {
	    key: 'getCellFromRefs',
	    value: function getCellFromRefs(rowId, columnKey) {
	      // Dumb hack to clean up existing hack.
	      var cell = this.getRowFromRefs(rowId).refs['column-' + columnKey];
	      // Unwrap
	      while (cell.decoratedComponentInstance) {
	        cell = cell.decoratedComponentInstance;
	      }
	      return cell;
	    }
	  }, {
	    key: 'getColumnFromKey',
	    value: function getColumnFromKey(key) {
	      var cols = this.props.columns || [];
	      return cols.find(function (col) {
	        return col.key === key;
	      });
	    }
	  }, {
	    key: 'handleClickOutside',
	    value: function handleClickOutside(event) {
	      if (this.state.editing) {
	        this.getCellFromRefs(this.state.editing.objectId, this.state.editing.columnKey).editor.handleBlur();
	      } else if (Object.keys(this.state.selectedRows).length !== 0 || Object.keys(this.state.selectedColumns).length !== 0) {
	        this.setState({ selectedRows: {}, selectedColumns: {} });
	      }
	      if (!(0, _jquery2.default)(event.target).closest('ul.actions').length) {
	        this.closeActions();
	      }
	    }
	  }, {
	    key: 'handleCopy',
	    value: function handleCopy(event) {
	      var clipboardData = event.originalEvent.clipboardData;
	      if (clipboardData) clipboardData.clearData();
	      var cellsData = [];
	      for (var rowIndex = 0; rowIndex < this.props.objects.length; rowIndex++) {
	        var row = this.props.objects[rowIndex];
	        if (Object.keys(this.state.selectedRows).length > 0 && typeof this.state.selectedRows[row.id] === 'undefined') {
	          continue;
	        }
	        var cellRow = [];
	        for (var columnIndex = 0; columnIndex < this.props.columns.length; columnIndex++) {
	          var column = this.props.columns[columnIndex];
	          if (Object.keys(this.state.selectedColumns).length > 0 && typeof this.state.selectedColumns[column.key] === 'undefined') {
	            continue;
	          }
	          cellRow.push(row[column.key]);
	        }
	        cellsData.push(cellRow);
	      }

	      var longestColumns = [];
	      for (var _rowIndex2 = 0; _rowIndex2 < cellsData.length; _rowIndex2++) {
	        for (var _columnIndex2 = 0; _columnIndex2 < cellsData[_rowIndex2].length; _columnIndex2++) {
	          var stringVal = (0, _clipboard.stringValue)(cellsData[_rowIndex2][_columnIndex2]);

	          if (typeof longestColumns[_columnIndex2] === 'undefined' || longestColumns[_columnIndex2] < stringVal.length) {
	            longestColumns[_columnIndex2] = stringVal.length;
	          }
	        }
	      }

	      var csvData = '';
	      for (var _rowIndex3 = 0; _rowIndex3 < cellsData.length; _rowIndex3++) {
	        for (var _columnIndex3 = 0; _columnIndex3 < cellsData[_rowIndex3].length; _columnIndex3++) {
	          var _stringVal = (0, _clipboard.stringValue)(cellsData[_rowIndex3][_columnIndex3]);
	          // let wrapQuotes = (stringVal.indexOf(',') != -1)
	          var wrapQuotes = false;
	          if (wrapQuotes) csvData += '"';
	          csvData += _stringVal.replace('\t', ' ');
	          if (wrapQuotes) csvData += '"';
	          if (_columnIndex3 !== cellsData[_rowIndex3].length - 1) csvData += '\t';
	        }
	        csvData += '\n';
	      }

	      clipboardData.setData('text/plain', csvData);
	      clipboardData.setData('react/object-grid', JSON.stringify(cellsData));
	      // clipboardData.setData('application/csv', csvData)
	      event.preventDefault();
	      this.setState(function (prevState) {
	        return {
	          copyingRows: prevState.selectedRows,
	          copyingColumns: prevState.selectedColumns
	        };
	      });
	    }
	  }, {
	    key: 'handlePaste',
	    value: function handlePaste(pasteData) {
	      var _this4 = this;

	      var raiseRowErrors = function raiseRowErrors(errors, row) {
	        var numErrors = Object.keys(errors).length;
	        if (numErrors) {
	          var message = void 0;
	          if (numErrors > 1) {
	            message = 'Invalid values given for ';
	          } else {
	            message = 'Invalid value given for ';
	          }
	          for (var columnKey in errors) {
	            message += columnKey;
	            message += ', ';
	          }
	          message = message.substring(0, message.length - 2);
	          message += '.';
	          _this4.props.onRowError(row, message);
	        }
	      };

	      // console.log('handling a paste of', pasteData)
	      var numSelectedRows = Object.keys(this.state.selectedRows).length;
	      var numSelectedColumns = Object.keys(this.state.selectedColumns).length;
	      if (numSelectedRows === 1 && numSelectedColumns === 1) {
	        var objectUpdates = [];

	        var newSelectionColumns = {};
	        var newSelectionRows = {};

	        var pastingRow = false;
	        var pastingRowIndex = 0;
	        for (var rowIndex = 0; rowIndex < this.props.objects.length; rowIndex++) {
	          var row = this.props.objects[rowIndex];
	          if (!pastingRow && typeof this.state.selectedRows[row.id] === 'undefined') {
	            continue;
	          }
	          pastingRow = true;
	          if (pastingRowIndex < pasteData.length) {
	            newSelectionRows[row.id] = true;
	            var pastingColumn = false;
	            var pastingColumnIndex = 0;
	            var updates = {};
	            var errors = {};
	            for (var columnIndex = 0; columnIndex < this.props.columns.length; columnIndex++) {
	              var column = this.props.columns[columnIndex];
	              if (!pastingColumn && typeof this.state.selectedColumns[column.key] === 'undefined') {
	                continue;
	              }
	              pastingColumn = true;
	              if (pastingColumnIndex < pasteData[pastingRowIndex].length) {
	                newSelectionColumns[column.key] = true;
	                if (!row.disabled && (0, _utilities.cellIsEditable)(row.id, column)) {
	                  var editor = column.editor || _text2.default;
	                  var validated = editor.validate(pasteData[pastingRowIndex][pastingColumnIndex], column.editorProps || {});
	                  if (validated.valid) {
	                    updates[column.key] = validated.cleanedValue;
	                  } else {
	                    errors[column.key] = true;
	                  }
	                }
	                pastingColumnIndex++;
	              }
	            }
	            if (Object.keys(updates).length) {
	              objectUpdates.push([row.id, updates]);
	            }
	            raiseRowErrors(errors, row);
	            pastingRowIndex++;
	          }
	        }
	        this.updateManyObjects(objectUpdates);
	        this.changeSelectionTo(newSelectionRows, newSelectionColumns);
	      } else {
	        var _objectUpdates = [];

	        var pasteRow = 0;
	        var pasteColumn = 0;
	        for (var _rowIndex4 = 0; _rowIndex4 < this.props.objects.length; _rowIndex4++) {
	          var _row2 = this.props.objects[_rowIndex4];
	          if (typeof this.state.selectedRows[_row2.id] === 'undefined') {
	            continue;
	          }
	          var _updates = {};
	          var _errors = {};
	          for (var _columnIndex4 = 0; _columnIndex4 < this.props.columns.length; _columnIndex4++) {
	            var _column2 = this.props.columns[_columnIndex4];
	            if (typeof this.state.selectedColumns[_column2.key] === 'undefined') {
	              continue;
	            }
	            if (!_row2.disabled && (0, _utilities.cellIsEditable)(_row2.id, _column2)) {
	              var _editor = _column2.editor || _text2.default;
	              var _validated = _editor.validate(pasteData[pasteRow][pasteColumn], _column2.editorProps || {});
	              if (_validated.valid) {
	                _updates[_column2.key] = _validated.cleanedValue;
	              } else {
	                _errors[_column2.key] = true;
	              }
	            }
	            pasteColumn++;
	            if (pasteColumn >= pasteData[pasteRow].length) pasteColumn = 0;
	          }
	          pasteColumn = 0;
	          if (Object.keys(_updates).length) {
	            _objectUpdates.push([_row2.id, _updates]);
	          }
	          raiseRowErrors(_errors, _row2);
	          pasteRow++;
	          if (pasteRow >= pasteData.length) pasteRow = 0;
	        }

	        this.updateManyObjects(_objectUpdates);
	      }
	      this.setState({ copyingColumns: {}, copyingRows: {} });
	    }
	  }, {
	    key: 'updateManyObjects',
	    value: function updateManyObjects(updates) {
	      if (typeof this.props.onUpdateMany === 'function') {
	        this.props.onUpdateMany(updates);
	      } else {
	        for (var updateId = 0; updateId < updates.length; updateId++) {
	          var update = updates[updateId];
	          this.updateObject(update[0], update[1]);
	        }
	      }
	    }
	  }, {
	    key: 'updateObject',
	    value: function updateObject(objectId, updates) {
	      if (typeof this.props.onUpdate === 'function') {
	        this.props.onUpdate(objectId, updates);
	      } else {
	        console.log('If I had a props.onUpdate, I would update object', objectId, 'with', updates);
	      }
	    }
	  }, {
	    key: 'moveSelectionTo',
	    value: function moveSelectionTo(row, column) {
	      var newRows = {};
	      var newColumns = {};
	      newRows[row] = true;
	      newColumns[column] = true;
	      this.changeSelectionTo(newRows, newColumns);
	    }
	  }, {
	    key: 'changeSelectionTo',
	    value: function changeSelectionTo(rows, columns) {
	      var newRows = rows;
	      var newColumns = columns;

	      var down = void 0;
	      if (Object.keys(this.state.selectedRows).length === 1 && Object.keys(newRows).length > 1) {
	        down = false;
	        var oldRow = (0, _utilities.dictFirstKey)(this.state.selectedRows);
	        for (var rowIndex = 0; rowIndex < this.props.objects.length; rowIndex++) {
	          var row = this.props.objects[rowIndex];
	          if (row.id === oldRow) {
	            down = true;
	            break;
	          }
	          if (typeof newRows[row.id] !== 'undefined') {
	            break;
	          }
	        }
	      }
	      if (Object.keys(newRows).length <= 1) {
	        down = true;
	      }

	      var right = void 0;
	      if (Object.keys(this.state.selectedColumns).length === 1 && Object.keys(newColumns).length > 1) {
	        right = false;
	        var oldColumn = (0, _utilities.dictFirstKey)(this.state.selectedColumns);
	        for (var columnIndex = 0; columnIndex < this.props.columns.length; columnIndex++) {
	          var column = this.props.columns[columnIndex];
	          if (column.key === oldColumn) {
	            right = true;
	            break;
	          }
	          if (typeof newColumns[column.key] !== 'undefined') {
	            break;
	          }
	        }
	      }
	      if (Object.keys(newColumns).length <= 1) {
	        right = true;
	      }

	      this.setState(function () {
	        var stateChanges = {
	          selectedRows: newRows,
	          selectedColumns: newColumns
	        };
	        if (typeof down !== 'undefined') stateChanges.selectedRowsDown = down;
	        if (typeof right !== 'undefined') stateChanges.selectedColumnsRight = right;
	        return stateChanges;
	      });
	    }
	  }, {
	    key: 'renderHeaders',
	    value: function renderHeaders() {
	      var _this5 = this;

	      var columns = [];
	      this.props.columns.map(function (column) {
	        var headerProps = {
	          ref: 'header-' + column.key,
	          key: 'header-' + column.key,
	          style: {
	            height: _this5.props.rowHeight + 'px'
	          }
	        };
	        if (column.width) headerProps.width = column.width;
	        columns.push(_react2.default.createElement(
	          'th',
	          _extends({
	            className: (0, _classnames2.default)(column.headerClassName || '')
	          }, headerProps),
	          column.name
	        ));
	      });

	      if (this.props.actions && this.props.actions.length) {
	        columns.push(_react2.default.createElement('th', {
	          ref: function ref(el) {
	            _this5.actions = el;
	          },
	          key: 'actions',
	          className: 'actions',
	          width: 25
	        }));
	      }

	      return _react2.default.createElement(
	        'tr',
	        null,
	        columns
	      );
	    }
	  }, {
	    key: 'renderRows',
	    value: function renderRows() {
	      var _this6 = this;

	      var numSelectedRows = Object.keys(this.state.selectedRows).length;
	      var numCopyingRows = Object.keys(this.state.copyingRows).length;
	      var rows = [];

	      this.props.objects.map(function (object) {
	        var ref = 'object-' + object.id;

	        var selectedColumns = {};
	        if (numSelectedRows === 0 || typeof _this6.state.selectedRows[object.id] !== 'undefined') {
	          selectedColumns = _this6.state.selectedColumns;
	        }
	        var copyingColumns = {};
	        if (numCopyingRows === 0 || typeof _this6.state.copyingRows[object.id] !== 'undefined') {
	          copyingColumns = _this6.state.copyingColumns;
	        }

	        var editing = null;
	        if (_this6.state.editing !== null && _this6.state.editing.objectId === object.id) {
	          editing = _this6.state.editing;
	        }

	        rows.push(_react2.default.createElement(_this6.props.rowComponent, _extends({}, _this6.props.rowProps, {
	          ref: ref,
	          key: ref,
	          object: object,

	          cellComponent: _this6.props.cellComponent,
	          cellProps: _this6.props.cellProps,
	          height: _this6.props.rowHeight,
	          columns: _this6.props.columns,
	          editing: editing,
	          editReplace: editing === null ? null : _this6.state.editReplace,
	          selectedColumns: selectedColumns,
	          copyingColumns: copyingColumns,
	          actions: _this6.props.actions,
	          actionsOpen: object.id === _this6.state.openActions,

	          updateField: _this6.updateField,
	          abortField: _this6.abortField,
	          cellError: _this6.props.onCellError,
	          openActions: _this6.openActions,
	          closeActions: _this6.closeActions,

	          onMouseDownCell: _this6.handleMouseDownCell,
	          beginEdit: _this6.beginEdit
	        })));
	      });

	      if (!rows.length) {
	        var numColumns = this.props.columns.length;
	        if (this.props.actions && this.props.actions.length) numColumns += 1;
	        return _react2.default.createElement(
	          'tr',
	          { style: { height: this.props.rowHeight } },
	          _react2.default.createElement(
	            'td',
	            { colSpan: numColumns, className: 'empty' },
	            this.props.emptyText
	          )
	        );
	      }
	      return rows;
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this7 = this;

	      var classes = (0, _classnames2.default)('', {
	        'editing': this.state.editing !== null
	      });
	      return _react2.default.createElement(
	        'div',
	        { className: 'object-table-container' },
	        _react2.default.createElement(
	          'table',
	          {
	            ref: function ref(el) {
	              _this7.table = el;
	            },
	            tabIndex: '1',
	            className: classes
	          },
	          _react2.default.createElement(
	            'thead',
	            null,
	            this.renderHeaders()
	          ),
	          _react2.default.createElement(
	            'tbody',
	            null,
	            this.renderRows()
	          )
	        )
	      );
	    }
	  }]);

	  return ObjectTable;
	}(_react2.default.PureComponent);

	ObjectTable.propTypes = {
	  columns: _propTypes2.default.array,
	  objects: _propTypes2.default.array,
	  onUpdateMany: _propTypes2.default.func,
	  onUpdate: _propTypes2.default.func,
	  rowHeight: _propTypes2.default.number,
	  actions: _propTypes2.default.array,
	  emptyText: _propTypes2.default.string,
	  onRowError: _propTypes2.default.func,
	  onCellError: _propTypes2.default.func,
	  rowComponent: _propTypes2.default.func,
	  rowProps: _propTypes2.default.object,
	  cellComponent: _propTypes2.default.func,
	  cellProps: _propTypes2.default.object
	};
	ObjectTable.defaultProps = {
	  rowComponent: _objectRow2.default,
	  cellComponent: _objectCell2.default,
	  rowHeight: 32,
	  objects: [{
	    id: 1, // every object is expected to have a unique identifier
	    name: 'Product item report',
	    quantity: '1.0000'
	  }],
	  columns: [{
	    name: 'Description',
	    key: 'description',
	    width: 'auto',
	    drawer: null,
	    drawerProps: null,
	    editor: null,
	    editorProps: null
	  }],
	  emptyText: 'No objects',
	  onRowError: function onRowError(row, message) {
	    console.warn('Unable to update row:', row);
	    console.warn('As the following error was encountered:', message);
	  },
	  onCellError: function onCellError(objectId, columnKey, message) {
	    console.warn('Unable to update row ' + objectId + ' ' + columnKey);
	    console.warn('As the following error was encountered:', message);
	  }
	};
	exports.default = ObjectTable;
	exports.ObjectCell = _objectCell2.default;
	exports.ObjectRow = _objectRow2.default;
	exports.BaseEditor = _baseEditor2.default;
	exports.TextEditor = _text2.default;
	exports.TextDrawer = _text4.default;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	if (process.env.NODE_ENV !== 'production') {
	  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
	    Symbol.for &&
	    Symbol.for('react.element')) ||
	    0xeac7;

	  var isValidElement = function(object) {
	    return typeof object === 'object' &&
	      object !== null &&
	      object.$$typeof === REACT_ELEMENT_TYPE;
	  };

	  // By explicitly using `prop-types` you are opting into new development behavior.
	  // http://fb.me/prop-types-in-prod
	  var throwOnDirectAccess = true;
	  module.exports = __webpack_require__(3)(isValidElement, throwOnDirectAccess);
	} else {
	  // By explicitly using `prop-types` you are opting into new production behavior.
	  // http://fb.me/prop-types-in-prod
	  module.exports = __webpack_require__(10)();
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 2 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;

	process.listeners = function (name) { return [] }

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	'use strict';

	var emptyFunction = __webpack_require__(4);
	var invariant = __webpack_require__(5);
	var warning = __webpack_require__(6);
	var assign = __webpack_require__(7);

	var ReactPropTypesSecret = __webpack_require__(8);
	var checkPropTypes = __webpack_require__(9);

	module.exports = function(isValidElement, throwOnDirectAccess) {
	  /* global Symbol */
	  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

	  /**
	   * Returns the iterator method function contained on the iterable object.
	   *
	   * Be sure to invoke the function with the iterable as context:
	   *
	   *     var iteratorFn = getIteratorFn(myIterable);
	   *     if (iteratorFn) {
	   *       var iterator = iteratorFn.call(myIterable);
	   *       ...
	   *     }
	   *
	   * @param {?object} maybeIterable
	   * @return {?function}
	   */
	  function getIteratorFn(maybeIterable) {
	    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  /**
	   * Collection of methods that allow declaration and validation of props that are
	   * supplied to React components. Example usage:
	   *
	   *   var Props = require('ReactPropTypes');
	   *   var MyArticle = React.createClass({
	   *     propTypes: {
	   *       // An optional string prop named "description".
	   *       description: Props.string,
	   *
	   *       // A required enum prop named "category".
	   *       category: Props.oneOf(['News','Photos']).isRequired,
	   *
	   *       // A prop named "dialog" that requires an instance of Dialog.
	   *       dialog: Props.instanceOf(Dialog).isRequired
	   *     },
	   *     render: function() { ... }
	   *   });
	   *
	   * A more formal specification of how these methods are used:
	   *
	   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	   *   decl := ReactPropTypes.{type}(.isRequired)?
	   *
	   * Each and every declaration produces a function with the same signature. This
	   * allows the creation of custom validation functions. For example:
	   *
	   *  var MyLink = React.createClass({
	   *    propTypes: {
	   *      // An optional string or URI prop named "href".
	   *      href: function(props, propName, componentName) {
	   *        var propValue = props[propName];
	   *        if (propValue != null && typeof propValue !== 'string' &&
	   *            !(propValue instanceof URI)) {
	   *          return new Error(
	   *            'Expected a string or an URI for ' + propName + ' in ' +
	   *            componentName
	   *          );
	   *        }
	   *      }
	   *    },
	   *    render: function() {...}
	   *  });
	   *
	   * @internal
	   */

	  var ANONYMOUS = '<<anonymous>>';

	  // Important!
	  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
	  var ReactPropTypes = {
	    array: createPrimitiveTypeChecker('array'),
	    bool: createPrimitiveTypeChecker('boolean'),
	    func: createPrimitiveTypeChecker('function'),
	    number: createPrimitiveTypeChecker('number'),
	    object: createPrimitiveTypeChecker('object'),
	    string: createPrimitiveTypeChecker('string'),
	    symbol: createPrimitiveTypeChecker('symbol'),

	    any: createAnyTypeChecker(),
	    arrayOf: createArrayOfTypeChecker,
	    element: createElementTypeChecker(),
	    instanceOf: createInstanceTypeChecker,
	    node: createNodeChecker(),
	    objectOf: createObjectOfTypeChecker,
	    oneOf: createEnumTypeChecker,
	    oneOfType: createUnionTypeChecker,
	    shape: createShapeTypeChecker,
	    exact: createStrictShapeTypeChecker,
	  };

	  /**
	   * inlined Object.is polyfill to avoid requiring consumers ship their own
	   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	   */
	  /*eslint-disable no-self-compare*/
	  function is(x, y) {
	    // SameValue algorithm
	    if (x === y) {
	      // Steps 1-5, 7-10
	      // Steps 6.b-6.e: +0 != -0
	      return x !== 0 || 1 / x === 1 / y;
	    } else {
	      // Step 6.a: NaN == NaN
	      return x !== x && y !== y;
	    }
	  }
	  /*eslint-enable no-self-compare*/

	  /**
	   * We use an Error-like object for backward compatibility as people may call
	   * PropTypes directly and inspect their output. However, we don't use real
	   * Errors anymore. We don't inspect their stack anyway, and creating them
	   * is prohibitively expensive if they are created too often, such as what
	   * happens in oneOfType() for any type before the one that matched.
	   */
	  function PropTypeError(message) {
	    this.message = message;
	    this.stack = '';
	  }
	  // Make `instanceof Error` still work for returned errors.
	  PropTypeError.prototype = Error.prototype;

	  function createChainableTypeChecker(validate) {
	    if (process.env.NODE_ENV !== 'production') {
	      var manualPropTypeCallCache = {};
	      var manualPropTypeWarningCount = 0;
	    }
	    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	      componentName = componentName || ANONYMOUS;
	      propFullName = propFullName || propName;

	      if (secret !== ReactPropTypesSecret) {
	        if (throwOnDirectAccess) {
	          // New behavior only for users of `prop-types` package
	          invariant(
	            false,
	            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	            'Use `PropTypes.checkPropTypes()` to call them. ' +
	            'Read more at http://fb.me/use-check-prop-types'
	          );
	        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
	          // Old behavior for people using React.PropTypes
	          var cacheKey = componentName + ':' + propName;
	          if (
	            !manualPropTypeCallCache[cacheKey] &&
	            // Avoid spamming the console because they are often not actionable except for lib authors
	            manualPropTypeWarningCount < 3
	          ) {
	            warning(
	              false,
	              'You are manually calling a React.PropTypes validation ' +
	              'function for the `%s` prop on `%s`. This is deprecated ' +
	              'and will throw in the standalone `prop-types` package. ' +
	              'You may be seeing this warning due to a third-party PropTypes ' +
	              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
	              propFullName,
	              componentName
	            );
	            manualPropTypeCallCache[cacheKey] = true;
	            manualPropTypeWarningCount++;
	          }
	        }
	      }
	      if (props[propName] == null) {
	        if (isRequired) {
	          if (props[propName] === null) {
	            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
	          }
	          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
	        }
	        return null;
	      } else {
	        return validate(props, propName, componentName, location, propFullName);
	      }
	    }

	    var chainedCheckType = checkType.bind(null, false);
	    chainedCheckType.isRequired = checkType.bind(null, true);

	    return chainedCheckType;
	  }

	  function createPrimitiveTypeChecker(expectedType) {
	    function validate(props, propName, componentName, location, propFullName, secret) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== expectedType) {
	        // `propValue` being instance of, say, date/regexp, pass the 'object'
	        // check, but we can offer a more precise error message here rather than
	        // 'of type `object`'.
	        var preciseType = getPreciseType(propValue);

	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createAnyTypeChecker() {
	    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
	  }

	  function createArrayOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	      }
	      var propValue = props[propName];
	      if (!Array.isArray(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	      }
	      for (var i = 0; i < propValue.length; i++) {
	        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createElementTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!isValidElement(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createInstanceTypeChecker(expectedClass) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!(props[propName] instanceof expectedClass)) {
	        var expectedClassName = expectedClass.name || ANONYMOUS;
	        var actualClassName = getClassName(props[propName]);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createEnumTypeChecker(expectedValues) {
	    if (!Array.isArray(expectedValues)) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
	      return emptyFunction.thatReturnsNull;
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      for (var i = 0; i < expectedValues.length; i++) {
	        if (is(propValue, expectedValues[i])) {
	          return null;
	        }
	      }

	      var valuesString = JSON.stringify(expectedValues);
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createObjectOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	      }
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	      }
	      for (var key in propValue) {
	        if (propValue.hasOwnProperty(key)) {
	          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	          if (error instanceof Error) {
	            return error;
	          }
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createUnionTypeChecker(arrayOfTypeCheckers) {
	    if (!Array.isArray(arrayOfTypeCheckers)) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	      return emptyFunction.thatReturnsNull;
	    }

	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (typeof checker !== 'function') {
	        warning(
	          false,
	          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
	          'received %s at index %s.',
	          getPostfixForTypeWarning(checker),
	          i
	        );
	        return emptyFunction.thatReturnsNull;
	      }
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	        var checker = arrayOfTypeCheckers[i];
	        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
	          return null;
	        }
	      }

	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createNodeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!isNode(props[propName])) {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      for (var key in shapeTypes) {
	        var checker = shapeTypes[key];
	        if (!checker) {
	          continue;
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createStrictShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      // We need to check all keys in case some are required but missing from
	      // props.
	      var allKeys = assign({}, props[propName], shapeTypes);
	      for (var key in allKeys) {
	        var checker = shapeTypes[key];
	        if (!checker) {
	          return new PropTypeError(
	            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
	            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
	            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
	          );
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }

	    return createChainableTypeChecker(validate);
	  }

	  function isNode(propValue) {
	    switch (typeof propValue) {
	      case 'number':
	      case 'string':
	      case 'undefined':
	        return true;
	      case 'boolean':
	        return !propValue;
	      case 'object':
	        if (Array.isArray(propValue)) {
	          return propValue.every(isNode);
	        }
	        if (propValue === null || isValidElement(propValue)) {
	          return true;
	        }

	        var iteratorFn = getIteratorFn(propValue);
	        if (iteratorFn) {
	          var iterator = iteratorFn.call(propValue);
	          var step;
	          if (iteratorFn !== propValue.entries) {
	            while (!(step = iterator.next()).done) {
	              if (!isNode(step.value)) {
	                return false;
	              }
	            }
	          } else {
	            // Iterator will provide entry [k,v] tuples rather than values.
	            while (!(step = iterator.next()).done) {
	              var entry = step.value;
	              if (entry) {
	                if (!isNode(entry[1])) {
	                  return false;
	                }
	              }
	            }
	          }
	        } else {
	          return false;
	        }

	        return true;
	      default:
	        return false;
	    }
	  }

	  function isSymbol(propType, propValue) {
	    // Native Symbol.
	    if (propType === 'symbol') {
	      return true;
	    }

	    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	    if (propValue['@@toStringTag'] === 'Symbol') {
	      return true;
	    }

	    // Fallback for non-spec compliant Symbols which are polyfilled.
	    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	      return true;
	    }

	    return false;
	  }

	  // Equivalent of `typeof` but with special handling for array and regexp.
	  function getPropType(propValue) {
	    var propType = typeof propValue;
	    if (Array.isArray(propValue)) {
	      return 'array';
	    }
	    if (propValue instanceof RegExp) {
	      // Old webkits (at least until Android 4.0) return 'function' rather than
	      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	      // passes PropTypes.object.
	      return 'object';
	    }
	    if (isSymbol(propType, propValue)) {
	      return 'symbol';
	    }
	    return propType;
	  }

	  // This handles more types than `getPropType`. Only used for error messages.
	  // See `createPrimitiveTypeChecker`.
	  function getPreciseType(propValue) {
	    if (typeof propValue === 'undefined' || propValue === null) {
	      return '' + propValue;
	    }
	    var propType = getPropType(propValue);
	    if (propType === 'object') {
	      if (propValue instanceof Date) {
	        return 'date';
	      } else if (propValue instanceof RegExp) {
	        return 'regexp';
	      }
	    }
	    return propType;
	  }

	  // Returns a string that is postfixed to a warning about an invalid type.
	  // For example, "undefined" or "of type array"
	  function getPostfixForTypeWarning(value) {
	    var type = getPreciseType(value);
	    switch (type) {
	      case 'array':
	      case 'object':
	        return 'an ' + type;
	      case 'boolean':
	      case 'date':
	      case 'regexp':
	        return 'a ' + type;
	      default:
	        return type;
	    }
	  }

	  // Returns class name of the object, if any.
	  function getClassName(propValue) {
	    if (!propValue.constructor || !propValue.constructor.name) {
	      return ANONYMOUS;
	    }
	    return propValue.constructor.name;
	  }

	  ReactPropTypes.checkPropTypes = checkPropTypes;
	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	"use strict";

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}

	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};

	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};

	module.exports = emptyFunction;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	var validateFormat = function validateFormat(format) {};

	if (process.env.NODE_ENV !== 'production') {
	  validateFormat = function validateFormat(format) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  };
	}

	function invariant(condition, format, a, b, c, d, e, f) {
	  validateFormat(format);

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}

	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	var emptyFunction = __webpack_require__(4);

	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */

	var warning = emptyFunction;

	if (process.env.NODE_ENV !== 'production') {
	  var printWarning = function printWarning(format) {
	    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }

	    var argIndex = 0;
	    var message = 'Warning: ' + format.replace(/%s/g, function () {
	      return args[argIndex++];
	    });
	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };

	  warning = function warning(condition, format) {
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }

	    if (format.indexOf('Failed Composite propType: ') === 0) {
	      return; // Ignore CompositeComponent proptype check.
	    }

	    if (!condition) {
	      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	        args[_key2 - 2] = arguments[_key2];
	      }

	      printWarning.apply(undefined, [format].concat(args));
	    }
	  };
	}

	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 7 */
/***/ (function(module, exports) {

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/

	'use strict';
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};


/***/ }),
/* 8 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	'use strict';

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	module.exports = ReactPropTypesSecret;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	'use strict';

	if (process.env.NODE_ENV !== 'production') {
	  var invariant = __webpack_require__(5);
	  var warning = __webpack_require__(6);
	  var ReactPropTypesSecret = __webpack_require__(8);
	  var loggedTypeFailures = {};
	}

	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?Function} getStack Returns the component stack.
	 * @private
	 */
	function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
	  if (process.env.NODE_ENV !== 'production') {
	    for (var typeSpecName in typeSpecs) {
	      if (typeSpecs.hasOwnProperty(typeSpecName)) {
	        var error;
	        // Prop type validation may throw. In case they do, we don't want to
	        // fail the render phase where it didn't fail before. So we log it.
	        // After these have been cleaned up, we'll let them throw.
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);
	          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	        } catch (ex) {
	          error = ex;
	        }
	        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
	        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	          // Only monitor this failure once because there tends to be a lot of the
	          // same error.
	          loggedTypeFailures[error.message] = true;

	          var stack = getStack ? getStack() : '';

	          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
	        }
	      }
	    }
	  }
	}

	module.exports = checkPropTypes;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	'use strict';

	var emptyFunction = __webpack_require__(4);
	var invariant = __webpack_require__(5);
	var ReactPropTypesSecret = __webpack_require__(8);

	module.exports = function() {
	  function shim(props, propName, componentName, location, propFullName, secret) {
	    if (secret === ReactPropTypesSecret) {
	      // It is still safe when called from React.
	      return;
	    }
	    invariant(
	      false,
	      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	      'Use PropTypes.checkPropTypes() to call them. ' +
	      'Read more at http://fb.me/use-check-prop-types'
	    );
	  };
	  shim.isRequired = shim;
	  function getShim() {
	    return shim;
	  };
	  // Important!
	  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
	  var ReactPropTypes = {
	    array: shim,
	    bool: shim,
	    func: shim,
	    number: shim,
	    object: shim,
	    string: shim,
	    symbol: shim,

	    any: shim,
	    arrayOf: getShim,
	    element: shim,
	    instanceOf: getShim,
	    node: shim,
	    objectOf: getShim,
	    oneOf: getShim,
	    oneOfType: getShim,
	    shape: getShim,
	    exact: getShim
	  };

	  ReactPropTypes.checkPropTypes = emptyFunction;
	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};


/***/ }),
/* 11 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_11__;

/***/ }),
/* 12 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_12__;

/***/ }),
/* 13 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_13__;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	  Copyright (c) 2016 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
	/* global define */

	(function () {
		'use strict';

		var hasOwn = {}.hasOwnProperty;

		function classNames () {
			var classes = [];

			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;

				var argType = typeof arg;

				if (argType === 'string' || argType === 'number') {
					classes.push(arg);
				} else if (Array.isArray(arg)) {
					classes.push(classNames.apply(null, arg));
				} else if (argType === 'object') {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				}
			}

			return classes.join(' ');
		}

		if (typeof module !== 'undefined' && module.exports) {
			module.exports = classNames;
		} else if (true) {
			// register as 'classnames', consistent with npm package name
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return classNames;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			window.classNames = classNames;
		}
	}());


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var clone = (function() {
	'use strict';

	/**
	 * Clones (copies) an Object using deep copying.
	 *
	 * This function supports circular references by default, but if you are certain
	 * there are no circular references in your object, you can save some CPU time
	 * by calling clone(obj, false).
	 *
	 * Caution: if `circular` is false and `parent` contains circular references,
	 * your program may enter an infinite loop and crash.
	 *
	 * @param `parent` - the object to be cloned
	 * @param `circular` - set to true if the object to be cloned may contain
	 *    circular references. (optional - true by default)
	 * @param `depth` - set to a number if the object is only to be cloned to
	 *    a particular depth. (optional - defaults to Infinity)
	 * @param `prototype` - sets the prototype to be used when cloning an object.
	 *    (optional - defaults to parent prototype).
	*/
	function clone(parent, circular, depth, prototype) {
	  var filter;
	  if (typeof circular === 'object') {
	    depth = circular.depth;
	    prototype = circular.prototype;
	    filter = circular.filter;
	    circular = circular.circular
	  }
	  // maintain two arrays for circular references, where corresponding parents
	  // and children have the same index
	  var allParents = [];
	  var allChildren = [];

	  var useBuffer = typeof Buffer != 'undefined';

	  if (typeof circular == 'undefined')
	    circular = true;

	  if (typeof depth == 'undefined')
	    depth = Infinity;

	  // recurse this function so we don't reset allParents and allChildren
	  function _clone(parent, depth) {
	    // cloning null always returns null
	    if (parent === null)
	      return null;

	    if (depth == 0)
	      return parent;

	    var child;
	    var proto;
	    if (typeof parent != 'object') {
	      return parent;
	    }

	    if (clone.__isArray(parent)) {
	      child = [];
	    } else if (clone.__isRegExp(parent)) {
	      child = new RegExp(parent.source, __getRegExpFlags(parent));
	      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
	    } else if (clone.__isDate(parent)) {
	      child = new Date(parent.getTime());
	    } else if (useBuffer && Buffer.isBuffer(parent)) {
	      child = new Buffer(parent.length);
	      parent.copy(child);
	      return child;
	    } else {
	      if (typeof prototype == 'undefined') {
	        proto = Object.getPrototypeOf(parent);
	        child = Object.create(proto);
	      }
	      else {
	        child = Object.create(prototype);
	        proto = prototype;
	      }
	    }

	    if (circular) {
	      var index = allParents.indexOf(parent);

	      if (index != -1) {
	        return allChildren[index];
	      }
	      allParents.push(parent);
	      allChildren.push(child);
	    }

	    for (var i in parent) {
	      var attrs;
	      if (proto) {
	        attrs = Object.getOwnPropertyDescriptor(proto, i);
	      }

	      if (attrs && attrs.set == null) {
	        continue;
	      }
	      child[i] = _clone(parent[i], depth - 1);
	    }

	    return child;
	  }

	  return _clone(parent, depth);
	}

	/**
	 * Simple flat clone using prototype, accepts only objects, usefull for property
	 * override on FLAT configuration object (no nested props).
	 *
	 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
	 * works.
	 */
	clone.clonePrototype = function clonePrototype(parent) {
	  if (parent === null)
	    return null;

	  var c = function () {};
	  c.prototype = parent;
	  return new c();
	};

	// private utility functions

	function __objToStr(o) {
	  return Object.prototype.toString.call(o);
	};
	clone.__objToStr = __objToStr;

	function __isDate(o) {
	  return typeof o === 'object' && __objToStr(o) === '[object Date]';
	};
	clone.__isDate = __isDate;

	function __isArray(o) {
	  return typeof o === 'object' && __objToStr(o) === '[object Array]';
	};
	clone.__isArray = __isArray;

	function __isRegExp(o) {
	  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
	};
	clone.__isRegExp = __isRegExp;

	function __getRegExpFlags(re) {
	  var flags = '';
	  if (re.global) flags += 'g';
	  if (re.ignoreCase) flags += 'i';
	  if (re.multiline) flags += 'm';
	  return flags;
	};
	clone.__getRegExpFlags = __getRegExpFlags;

	return clone;
	})();

	if (typeof module === 'object' && module.exports) {
	  module.exports = clone;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16).Buffer))

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */

	'use strict'

	var base64 = __webpack_require__(17)
	var ieee754 = __webpack_require__(18)
	var isArray = __webpack_require__(19)

	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()

	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	exports.kMaxLength = kMaxLength()

	function typedArraySupport () {
	  try {
	    var arr = new Uint8Array(1)
	    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length)
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length)
	    }
	    that.length = length
	  }

	  return that
	}

	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */

	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}

	Buffer.poolSize = 8192 // not used by this implementation

	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype
	  return arr
	}

	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }

	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }

	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }

	  return fromObject(that, value)
	}

	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	}

	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) {
	    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true
	    })
	  }
	}

	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}

	function alloc (that, size, fill, encoding) {
	  assertSize(size)
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}

	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	}

	function allocUnsafe (that, size) {
	  assertSize(size)
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0
	    }
	  }
	  return that
	}

	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	}
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	}

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8'
	  }

	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }

	  var length = byteLength(string, encoding) | 0
	  that = createBuffer(that, length)

	  var actual = that.write(string, encoding)

	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual)
	  }

	  return that
	}

	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0
	  that = createBuffer(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength // this throws if `array` is not a valid ArrayBuffer

	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }

	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }

	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array)
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset)
	  } else {
	    array = new Uint8Array(array, byteOffset, length)
	  }

	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array)
	  }
	  return that
	}

	function fromObject (that, obj) {
	  if (Buffer.isBuffer(obj)) {
	    var len = checked(obj.length) | 0
	    that = createBuffer(that, len)

	    if (that.length === 0) {
	      return that
	    }

	    obj.copy(that, 0, 0, len)
	    return that
	  }

	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }

	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }

	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0
	  }
	  return Buffer.alloc(+length)
	}

	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length
	  var y = b.length

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i]
	      y = b[i]
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}

	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }

	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }

	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length
	    }
	  }

	  var buffer = Buffer.allocUnsafe(length)
	  var pos = 0
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i]
	    if (!Buffer.isBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos)
	    pos += buf.length
	  }
	  return buffer
	}

	function byteLength (string, encoding) {
	  if (Buffer.isBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string
	  }

	  var len = string.length
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength

	function slowToString (encoding, start, end) {
	  var loweredCase = false

	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.

	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }

	  if (end === undefined || end > this.length) {
	    end = this.length
	  }

	  if (end <= 0) {
	    return ''
	  }

	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0
	  start >>>= 0

	  if (end <= start) {
	    return ''
	  }

	  if (!encoding) encoding = 'utf8'

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true

	function swap (b, n, m) {
	  var i = b[n]
	  b[n] = b[m]
	  b[m] = i
	}

	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1)
	  }
	  return this
	}

	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3)
	    swap(this, i + 1, i + 2)
	  }
	  return this
	}

	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7)
	    swap(this, i + 1, i + 6)
	    swap(this, i + 2, i + 5)
	    swap(this, i + 3, i + 4)
	  }
	  return this
	}

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}

	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}

	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}

	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!Buffer.isBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }

	  if (start === undefined) {
	    start = 0
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0
	  }
	  if (thisStart === undefined) {
	    thisStart = 0
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length
	  }

	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }

	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }

	  start >>>= 0
	  end >>>= 0
	  thisStart >>>= 0
	  thisEnd >>>= 0

	  if (this === target) return 0

	  var x = thisEnd - thisStart
	  var y = end - start
	  var len = Math.min(x, y)

	  var thisCopy = this.slice(thisStart, thisEnd)
	  var targetCopy = target.slice(start, end)

	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i]
	      y = targetCopy[i]
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1

	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset
	    byteOffset = 0
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000
	  }
	  byteOffset = +byteOffset  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1)
	  }

	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0
	    else return -1
	  }

	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding)
	  }

	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (Buffer.isBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1
	  var arrLength = arr.length
	  var valLength = val.length

	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase()
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2
	      arrLength /= 2
	      valLength /= 2
	      byteOffset /= 2
	    }
	  }

	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }

	  var i
	  if (dir) {
	    var foundIndex = -1
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex
	        foundIndex = -1
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false
	          break
	        }
	      }
	      if (found) return i
	    }
	  }

	  return -1
	}

	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	}

	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	}

	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	}

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }

	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8'

	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []

	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }

	    res.push(codePoint)
	    i += bytesPerSequence
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}

	function latin1Slice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length

	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len

	  var out = ''
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i])
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end

	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }

	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }

	  if (end < start) end = start

	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end)
	    newBuf.__proto__ = Buffer.prototype
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start]
	    }
	  }

	  return newBuf
	}

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }

	  return val
	}

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }

	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }

	  return val
	}

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }

	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = 0
	  var mul = 1
	  var sub = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  var sub = 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }

	  var len = end - start
	  var i

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    )
	  }

	  return len
	}

	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start
	      start = 0
	      end = this.length
	    } else if (typeof end === 'string') {
	      encoding = end
	      end = this.length
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0)
	      if (code < 256) {
	        val = code
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255
	  }

	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }

	  if (end <= start) {
	    return this
	  }

	  start = start >>> 0
	  end = end === undefined ? this.length : end >>> 0

	  if (!val) val = 0

	  var i
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val
	    }
	  } else {
	    var bytes = Buffer.isBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString())
	    var len = bytes.length
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len]
	    }
	  }

	  return this
	}

	// HELPER FUNCTIONS
	// ================

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []

	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i)

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }

	    leadSurrogate = null

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }

	  return byteArray
	}

	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}

	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 17 */
/***/ (function(module, exports) {

	'use strict'

	exports.byteLength = byteLength
	exports.toByteArray = toByteArray
	exports.fromByteArray = fromByteArray

	var lookup = []
	var revLookup = []
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i]
	  revLookup[code.charCodeAt(i)] = i
	}

	revLookup['-'.charCodeAt(0)] = 62
	revLookup['_'.charCodeAt(0)] = 63

	function placeHoldersCount (b64) {
	  var len = b64.length
	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
	}

	function byteLength (b64) {
	  // base64 is 4/3 + up to two characters of the original data
	  return (b64.length * 3 / 4) - placeHoldersCount(b64)
	}

	function toByteArray (b64) {
	  var i, l, tmp, placeHolders, arr
	  var len = b64.length
	  placeHolders = placeHoldersCount(b64)

	  arr = new Arr((len * 3 / 4) - placeHolders)

	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len

	  var L = 0

	  for (i = 0; i < l; i += 4) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
	    arr[L++] = (tmp >> 16) & 0xFF
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }

	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
	    arr[L++] = tmp & 0xFF
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }

	  return arr
	}

	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}

	function encodeChunk (uint8, start, end) {
	  var tmp
	  var output = []
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
	    output.push(tripletToBase64(tmp))
	  }
	  return output.join('')
	}

	function fromByteArray (uint8) {
	  var tmp
	  var len = uint8.length
	  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
	  var output = ''
	  var parts = []
	  var maxChunkLength = 16383 // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1]
	    output += lookup[tmp >> 2]
	    output += lookup[(tmp << 4) & 0x3F]
	    output += '=='
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
	    output += lookup[tmp >> 10]
	    output += lookup[(tmp >> 4) & 0x3F]
	    output += lookup[(tmp << 2) & 0x3F]
	    output += '='
	  }

	  parts.push(output)

	  return parts.join('')
	}


/***/ }),
/* 18 */
/***/ (function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]

	  i += d

	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

	  value = Math.abs(value)

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }

	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128
	}


/***/ }),
/* 19 */
/***/ (function(module, exports) {

	var toString = {}.toString;

	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ }),
/* 20 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	function dictCount(dict) {
	  var count = 0;
	  for (var _ in dict) {
	    count++;
	  }
	  return count;
	}

	function dictFirstKey(dict) {
	  for (var dictKey in dict) {
	    return dictKey;
	  }
	  return undefined;
	}

	function cellIsEditable(object, column) {
	  var isReadOnly = column.isReadOnly,
	      editor = column.editor;

	  var editorIsSet = editor !== false;
	  var readOnly = typeof isReadOnly === 'function' ? isReadOnly(object) : isReadOnly === true;
	  return editorIsSet && !readOnly;
	}

	function isDifferent(objectA, objectB, exemptions) {
	  for (var key in objectA) {
	    if (exemptions && key in exemptions) {
	      continue;
	    }
	    if (JSON.stringify(objectB[key]) !== JSON.stringify(objectA[key])) {
	      return true;
	    }
	  }
	  return false;
	}

	exports.dictCount = dictCount;
	exports.dictFirstKey = dictFirstKey;
	exports.cellIsEditable = cellIsEditable;
	exports.isDifferent = isDifferent;

/***/ }),
/* 21 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	function deserializeCells(clipboardData) {
	  var gridData = clipboardData.getData('react/object-grid');
	  if (gridData) {
	    return JSON.parse(gridData);
	  }
	  var tabbedData = clipboardData.getData('text/plain');
	  if (tabbedData) {
	    var rows = [];
	    var lines = tabbedData.split('\n');
	    for (var lineIndex = 0; lineIndex < lines.length; lineIndex++) {
	      var columns = [];
	      var tabs = lines[lineIndex].split('\t');
	      for (var tabIndex = 0; tabIndex < tabs.length; tabIndex++) {
	        columns.push(tabs[tabIndex]);
	      }
	      rows.push(columns);
	    }
	    return rows;
	  }
	  return [];
	}

	function stringValue(value) {
	  switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
	    case 'number':
	      return value.toString();

	    case 'object':
	      if (Array.isArray(value)) {
	        var _stringValue = '';
	        for (var valueIndex = 0; valueIndex < value.length; valueIndex++) {
	          _stringValue += _stringValue(value[valueIndex]);
	          if (valueIndex < value.length - 1) {
	            _stringValue += ', ';
	          }
	        }
	        return _stringValue;
	      }

	      if (value === null) {
	        return '';
	      } else {
	        return 'object';
	      }

	    case 'boolean':
	      if (value) {
	        return 'true';
	      } else {
	        return 'false';
	      }

	    case 'string':
	      return value;
	  }
	  return '';
	}

	exports.deserializeCells = deserializeCells;
	exports.stringValue = stringValue;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(11);

	var _react2 = _interopRequireDefault(_react);

	var _baseEditor = __webpack_require__(23);

	var _baseEditor2 = _interopRequireDefault(_baseEditor);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _validate(value, props) {
	  return {
	    valid: true,
	    cleanedValue: String(value)
	  };
	}

	var TextEditor = function (_BaseEditor) {
	  _inherits(TextEditor, _BaseEditor);

	  function TextEditor() {
	    var _ref;

	    var _temp, _this, _ret;

	    _classCallCheck(this, TextEditor);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = TextEditor.__proto__ || Object.getPrototypeOf(TextEditor)).call.apply(_ref, [this].concat(args))), _this), _this.handleChange = function (event) {
	      var newValue = _this.field.value;
	      _this.setState({ value: newValue });
	    }, _this.handleFocus = function (event) {
	      if (_this.props.editReplace === null) {
	        window.setTimeout(function () {
	          var inputElement = _this.field;
	          inputElement.select();
	        }, 0);
	      }
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  _createClass(TextEditor, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      if (this.props.editReplace) {
	        this.field.setSelectionRange(this.state.value.length, this.state.value.length);
	      }
	    }
	  }, {
	    key: 'validate',
	    value: function validate(value) {
	      return _validate(value, this.props);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;

	      return _react2.default.createElement(
	        'form',
	        {
	          onSubmit: this.handleSubmit,
	          onKeyDown: this.handleKeyDown
	        },
	        _react2.default.createElement('input', {
	          ref: function ref(el) {
	            _this2.field = el;
	          },
	          value: this.state.value,
	          onChange: this.handleChange,
	          onBlur: this.handleBlur,
	          onFocus: this.handleFocus,
	          autoFocus: true,
	          style: {
	            height: '' + (this.props.height - 2) + 'px',
	            lineHeight: '' + (this.props.height - 2) + 'px'
	            // fontSize: '' + (this.props.height - 4) + 'px',
	          }
	        })
	      );
	    }
	  }]);

	  return TextEditor;
	}(_baseEditor2.default);

	exports.default = {
	  className: 'text-editor',
	  component: TextEditor,
	  validate: _validate
	};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _propTypes = __webpack_require__(1);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _react = __webpack_require__(11);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _validate(value, props) {
	  return {
	    valid: true,
	    cleanedValue: value
	  };
	}

	var BaseEditor = function (_React$Component) {
	  _inherits(BaseEditor, _React$Component);

	  function BaseEditor() {
	    var _ref;

	    var _temp, _this, _ret;

	    _classCallCheck(this, BaseEditor);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = BaseEditor.__proto__ || Object.getPrototypeOf(BaseEditor)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
	      value: _this.props.editReplace !== null ? _this.props.editReplace : _this.props.value
	    }, _this.handleBlur = function (event) {
	      _this.commit(_this.state.value, false);
	    }, _this.handleSubmit = function (event) {
	      event.preventDefault();
	      _this.commit(_this.state.value, 'nextRow');
	    }, _this.handleKeyDown = function (event) {
	      if (event.which === 9) {
	        event.preventDefault();
	        _this.commit(_this.state.value, 'nextColumn');
	      }
	      if (event.which === 27) {
	        event.preventDefault();
	        _this.abort(false);
	      }
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  _createClass(BaseEditor, [{
	    key: 'validate',
	    value: function validate(value) {
	      return _validate(value, this.props);
	    }
	  }, {
	    key: 'abort',
	    value: function abort(nextAction) {
	      this.props.abort(nextAction);
	    }
	  }, {
	    key: 'commit',
	    value: function commit(value, nextAction) {
	      var validation = this.validate(value);

	      if (validation.valid) {
	        this.props.update(this.props.objectId, this.props.columnKey, validation.cleanedValue, nextAction);
	      } else {
	        this.props.cellError(this.props.objectId, this.props.columnKey, '"' + value + '" is not a valid value.');
	        this.abort(nextAction);
	      }
	    }
	  }]);

	  return BaseEditor;
	}(_react2.default.Component);

	BaseEditor.propTypes = {
	  editReplace: _propTypes2.default.any,
	  value: _propTypes2.default.any,
	  abort: _propTypes2.default.func,
	  update: _propTypes2.default.func,
	  cellError: _propTypes2.default.func,
	  objectId: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
	  columnKey: _propTypes2.default.string
	};
	BaseEditor.defaultProps = {
	  editReplace: null
	};
	exports.default = BaseEditor;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _propTypes = __webpack_require__(1);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _react = __webpack_require__(11);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var TextDrawer = function (_React$Component) {
	  _inherits(TextDrawer, _React$Component);

	  function TextDrawer() {
	    _classCallCheck(this, TextDrawer);

	    return _possibleConstructorReturn(this, (TextDrawer.__proto__ || Object.getPrototypeOf(TextDrawer)).apply(this, arguments));
	  }

	  _createClass(TextDrawer, [{
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement(
	        'span',
	        null,
	        String(this.props.value)
	      );
	    }
	  }]);

	  return TextDrawer;
	}(_react2.default.Component);

	TextDrawer.propTypes = {
	  value: _propTypes2.default.string
	};
	exports.default = {
	  className: 'text-drawer',
	  component: TextDrawer
	};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _propTypes = __webpack_require__(1);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _react = __webpack_require__(11);

	var _react2 = _interopRequireDefault(_react);

	var _clone = __webpack_require__(15);

	var _clone2 = _interopRequireDefault(_clone);

	var _classnames = __webpack_require__(14);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _utilities = __webpack_require__(20);

	var _text = __webpack_require__(24);

	var _text2 = _interopRequireDefault(_text);

	var _text3 = __webpack_require__(22);

	var _text4 = _interopRequireDefault(_text3);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var ObjectCell = function (_React$Component) {
	  _inherits(ObjectCell, _React$Component);

	  function ObjectCell() {
	    var _ref;

	    var _temp, _this, _ret;

	    _classCallCheck(this, ObjectCell);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ObjectCell.__proto__ || Object.getPrototypeOf(ObjectCell)).call.apply(_ref, [this].concat(args))), _this), _this.handleMouseDown = function (event) {
	      var button = event.which || event.button;
	      event.preventDefault();
	      if (button === 0) {
	        _this.props.onMouseDownCell(_this.getCellRef(), event.clientX, event.clientY, event.shiftKey);
	      }
	    }, _this.handleDoubleClick = function (event) {
	      _this.beginEdit();
	    }, _this.beginEdit = function (editReplaceOverride) {
	      if (!_this.props.disabled && _this.editable(_this.props.object)) {
	        _this.props.beginEdit(_this.getCellRef(), editReplaceOverride);
	      }
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  _createClass(ObjectCell, [{
	    key: 'shouldComponentUpdate',
	    value: function shouldComponentUpdate(nextProps, nextState) {
	      var propsExemptions = {
	        'onMouseDownCell': true,
	        'beginEdit': true,
	        'updateField': true,
	        'abortField': true,
	        'cellError': true
	      };
	      if ((0, _utilities.isDifferent)(this.props, nextProps, propsExemptions)) {
	        return true;
	      }
	      if ((0, _utilities.isDifferent)(this.state, nextState)) {
	        return true;
	      }
	      return false;
	    }
	  }, {
	    key: 'getCellRef',
	    value: function getCellRef() {
	      return {
	        columnKey: this.props.column.key,
	        objectId: this.props.objectId
	      };
	    }
	  }, {
	    key: 'editable',
	    value: function editable(object) {
	      return (0, _utilities.cellIsEditable)(object, this.props.column);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;

	      var classes = (0, _classnames2.default)('', {
	        'selected': this.props.selected,
	        'copying': this.props.copying,
	        'editing': this.props.editing
	      });

	      if (this.props.editing) {
	        var editor = this.props.column.editor || _text4.default;
	        var editorProps = (0, _clone2.default)(this.props.column.editorProps || {});
	        editorProps.value = this.props.value;
	        editorProps.update = this.props.updateField;
	        editorProps.abort = this.props.abortField;
	        editorProps.objectId = this.props.objectId;
	        editorProps.column = this.props.column;
	        editorProps.object = this.props.object;
	        editorProps.columnKey = this.props.column.key;
	        editorProps.height = this.props.height;
	        editorProps.editReplace = this.props.editReplace;
	        editorProps.cellError = this.props.cellError;
	        editorProps.context = this.props.editorContext;

	        return _react2.default.createElement(
	          'td',
	          {
	            className: classes + ' editor ' + editor.className
	          },
	          _react2.default.createElement(
	            'div',
	            { className: 'contents' },
	            _react2.default.createElement(editor.component, _extends({}, editorProps, {
	              ref: function ref(el) {
	                _this2.editor = el;
	              }
	            }), null)
	          )
	        );
	      } else {
	        var drawer = this.props.column.drawer || _text2.default;
	        var drawerProps = (0, _clone2.default)(this.props.column.drawerProps || {});

	        drawerProps.value = this.props.value;
	        drawerProps.column = this.props.column;
	        drawerProps.object = this.props.object;
	        drawerProps.beginEdit = this.beginEdit;
	        drawerProps.context = this.props.drawerContext;

	        var cellProps = {
	          className: (0, _classnames2.default)(classes + ' drawer ' + drawer.className, {
	            uneditable: !this.editable(this.props.object)
	          })
	        };
	        if (!this.props.column.disableInteraction) {
	          cellProps = _extends({}, cellProps, {
	            onMouseDown: this.handleMouseDown,
	            onDoubleClick: this.handleDoubleClick
	          });
	        }

	        return _react2.default.createElement(
	          'td',
	          cellProps,
	          _react2.default.createElement(
	            'div',
	            { className: 'contents' },
	            _react2.default.createElement(drawer.component, _extends({}, drawerProps, {
	              ref: function ref(el) {
	                _this2.drawer = el;
	              }
	            }), null)
	          )
	        );
	      }
	    }
	  }]);

	  return ObjectCell;
	}(_react2.default.Component);

	ObjectCell.propTypes = {
	  column: _propTypes2.default.object,
	  objectId: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
	  object: _propTypes2.default.object,
	  onMouseDownCell: _propTypes2.default.func,
	  disabled: _propTypes2.default.bool,
	  beginEdit: _propTypes2.default.func,
	  selected: _propTypes2.default.bool,
	  copying: _propTypes2.default.bool,
	  editing: _propTypes2.default.bool,
	  value: _propTypes2.default.any,
	  updateField: _propTypes2.default.func,
	  abortField: _propTypes2.default.func,
	  height: _propTypes2.default.number,
	  editReplace: _propTypes2.default.any,
	  cellError: _propTypes2.default.func,
	  editorContext: _propTypes2.default.object,
	  drawerContext: _propTypes2.default.object
	};
	exports.default = ObjectCell;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _propTypes = __webpack_require__(1);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _react = __webpack_require__(11);

	var _react2 = _interopRequireDefault(_react);

	var _jquery = __webpack_require__(13);

	var _jquery2 = _interopRequireDefault(_jquery);

	var _classnames = __webpack_require__(14);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _utilities = __webpack_require__(20);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var ObjectRow = function (_React$Component) {
	  _inherits(ObjectRow, _React$Component);

	  function ObjectRow() {
	    var _ref;

	    var _temp, _this, _ret;

	    _classCallCheck(this, ObjectRow);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ObjectRow.__proto__ || Object.getPrototypeOf(ObjectRow)).call.apply(_ref, [this].concat(args))), _this), _this.openActions = function (event) {
	      _this.props.openActions(_this.props.object.id);
	    }, _this.closeActions = function (event) {
	      _this.props.closeActions();
	    }, _this.onActionClick = function (event) {
	      var actionId = (0, _jquery2.default)(event.target).data('action');
	      var action = _this.props.actions[actionId];
	      if (action) {
	        _this.props.actions[actionId].func(_this.props.object.id);
	        if (!action.stayOpen) {
	          _this.props.closeActions();
	        }
	      }
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  _createClass(ObjectRow, [{
	    key: 'shouldComponentUpdate',
	    value: function shouldComponentUpdate(nextProps, nextState) {
	      var isMissingColumns = function isMissingColumns(propsA, propsB, columnsKey) {
	        for (var key in propsA[columnsKey]) {
	          if (key in propsB[columnsKey] === false) {
	            // console.log('key', key, 'does not exist in both')
	            return true;
	          }
	        }
	        return false;
	      };
	      if (isMissingColumns(nextProps, this.props, 'selectedColumns') || isMissingColumns(this.props, nextProps, 'selectedColumns')) {
	        return true;
	      }
	      if (isMissingColumns(nextProps, this.props, 'copyingColumns') || isMissingColumns(this.props, nextProps, 'copyingColumns')) {
	        return true;
	      }

	      var propsExemptions = {
	        // ignore column we perform above
	        'selectedColumns': true,
	        'copyingColumns': true,

	        // ignore bound methods
	        'updateField': true,
	        'abortField': true,
	        'openActions': true,
	        'closeActions': true,
	        'onMouseDownCell': true,
	        'beginEdit': true
	      };
	      if ((0, _utilities.isDifferent)(this.props, nextProps, propsExemptions)) {
	        return true;
	      }
	      if ((0, _utilities.isDifferent)(this.state, nextState)) {
	        return true;
	      }
	      return false;
	    }
	  }, {
	    key: 'colInRanges',
	    value: function colInRanges(column, columns, rows) {
	      var numRangeColumns = (0, _utilities.dictCount)(columns);
	      var numRangeRows = (0, _utilities.dictCount)(rows);
	      if (numRangeColumns === 0 && numRangeRows === 0) {
	        return false;
	      } else if (columns !== null && rows === null) {
	        return typeof columns[column.key] !== 'undefined';
	      } else if (columns === null && rows !== null) {
	        return true;
	      }
	      return typeof columns[column.key] !== 'undefined' && typeof rows[this.props.object.id] !== 'undefined';
	    }
	  }, {
	    key: 'renderCells',
	    value: function renderCells() {
	      var _this2 = this;

	      var cells = [];
	      for (var columnIndex = 0; columnIndex < this.props.columns.length; columnIndex++) {
	        var column = this.props.columns[columnIndex];
	        var editing = false;
	        if (this.props.editing !== null) {
	          editing = this.props.editing.objectId === this.props.object.id && this.props.editing.columnKey === column.key;
	        }

	        var ref = 'column-' + column.key;

	        var cellProps = {
	          key: ref,
	          ref: ref,

	          value: this.props.object[column.key],
	          objectId: this.props.object.id,
	          object: this.props.object,

	          column: column,
	          height: this.props.height,
	          editReplace: this.props.editReplace,
	          selected: typeof this.props.selectedColumns[column.key] !== 'undefined',
	          copying: typeof this.props.copyingColumns[column.key] !== 'undefined',

	          onMouseDownCell: this.props.onMouseDownCell,
	          beginEdit: this.props.beginEdit,

	          updateField: this.props.updateField,
	          abortField: this.props.abortField,
	          cellError: this.props.cellError
	        };

	        cellProps.editorContext = null;
	        if (editing && column.editorContext) {
	          cellProps.editorContext = column.editorContext(this.props.object);
	        }
	        if (!editing && column.drawerContext) {
	          cellProps.drawerContext = column.drawerContext(this.props.object);
	        }

	        cellProps.disabled = this.props.object.disabled === true;
	        if (this.props.object.disabled) {
	          cellProps.editing = false;
	        } else {
	          cellProps.editing = editing;
	        }
	        cells.push(_react2.default.createElement(this.props.cellComponent, _extends({}, this.props.cellProps, cellProps)));
	      }
	      if (this.props.actions && this.props.actions.length) {
	        var cellStyle = {
	          lineHeight: this.props.height + 'px'
	        };
	        if (this.props.actionsOpen && !this.props.object.disabled) {
	          var actions = [];
	          this.props.actions.map(function (action, index) {
	            var actionEnabled = action.enabled;
	            var tooltip = void 0;
	            if (!(actionEnabled === undefined)) {
	              if (typeof actionEnabled === 'function') actionEnabled = actionEnabled(_this2.props.object);
	              if (Array.isArray(actionEnabled)) {
	                var _actionEnabled = actionEnabled;

	                var _actionEnabled2 = _slicedToArray(_actionEnabled, 2);

	                actionEnabled = _actionEnabled2[0];
	                tooltip = _actionEnabled2[1];
	              }
	            } else {
	              actionEnabled = true;
	            }
	            actions.push(_react2.default.createElement(
	              'li',
	              {
	                key: 'action-' + index,
	                title: tooltip,
	                className: (0, _classnames2.default)({ 'disabled': !actionEnabled }, 'action'),
	                onClick: actionEnabled ? _this2.onActionClick : null,
	                'data-action': index
	              },
	              action.label
	            ));
	          });
	          cells.push(_react2.default.createElement(
	            'td',
	            {
	              key: 'actions',
	              ref: function ref(el) {
	                _this2.actions = el;
	              },
	              className: 'actions open',
	              style: cellStyle
	            },
	            _react2.default.createElement(
	              'span',
	              { onClick: this.closeActions },
	              '\u2630'
	            ),
	            _react2.default.createElement(
	              'ul',
	              { className: 'actions' },
	              actions
	            )
	          ));
	        } else {
	          cells.push(_react2.default.createElement(
	            'td',
	            {
	              key: 'actions',
	              ref: function ref(el) {
	                _this2.actions = el;
	              },
	              className: 'actions closed',
	              onClick: this.openActions,
	              style: cellStyle
	            },
	            _react2.default.createElement(
	              'span',
	              null,
	              '\u2630'
	            )
	          ));
	        }
	      }
	      return cells;
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement(
	        'tr',
	        {
	          className: (0, _classnames2.default)('', { disabled: this.props.object.disabled === true }),
	          style: {
	            height: '' + this.props.height + 'px'
	          }
	        },
	        this.renderCells()
	      );
	    }
	  }]);

	  return ObjectRow;
	}(_react2.default.Component);

	ObjectRow.propTypes = {
	  id: _propTypes2.default.number,
	  object: _propTypes2.default.object,
	  openActions: _propTypes2.default.func,
	  closeActions: _propTypes2.default.func,
	  actions: _propTypes2.default.array,
	  columns: _propTypes2.default.array,
	  editing: _propTypes2.default.object,
	  height: _propTypes2.default.number,
	  editReplace: _propTypes2.default.any,
	  selectedColumns: _propTypes2.default.object,
	  copyingColumns: _propTypes2.default.object,
	  onMouseDownCell: _propTypes2.default.func,
	  beginEdit: _propTypes2.default.func,
	  updateField: _propTypes2.default.func,
	  abortField: _propTypes2.default.func,
	  cellError: _propTypes2.default.func,
	  actionsOpen: _propTypes2.default.bool,
	  cellComponent: _propTypes2.default.func,
	  cellProps: _propTypes2.default.object
	};
	exports.default = ObjectRow;

/***/ })
/******/ ])
});
;